#include "stm8s.h"
#include "stm8s_spi.h"
#include "stm8s_tim2.h"
#include "stm8s_tim4.h"
//#include "stdio.h"
#include "string.h"

//User Define
#define BLE_Power GPIO_PIN_3
#define BLE_Power_Port GPIOD
#define BLE_PWC GPIO_PIN_5
#define BLE_PWC_Port GPIOC

#define Speaker_Pin GPIO_PIN_2
#define Speaker_Port GPIOD
#define Led_Pin GPIO_PIN_6
#define Led_Port GPIOC

#define Epp_WirteProtect_Pin GPIO_PIN_3
#define Epp_WirteProtect_Port GPIOC
#define Cps_Ready_Pin GPIO_PIN_3
#define Cps_Ready_Port GPIOA

#define Power_Pin GPIO_PIN_4
#define Power_Port GPIOC
#define Key_Pin GPIO_PIN_4
#define Key_Port GPIOD

//*********
//Funtion def
void rccConfig();
// void spiInit();
void uartInit(uint32_t baudRate);
void uartSend(char* message);
void ioInit();
bool delay_us(uint16_t delayTime); // delay time in range 10 ~ 1995
bool delay_ms(uint16_t delayTime); // 
void speak_Ring(int ring[], int size);
void power_IO(bool state);

//***********
//Variable def

int r_Start[7] = {10, 9, 8, 7, 6, 5, 4};
int r_Stop[7] = {4, 5, 6, 7, 8, 9, 10};
int r_Recive[2] = {2, 3};
int r_Error[2] = {30};
uint32_t millis = 0;

int n_Tone = 150;
bool b_Power = FALSE;
bool b_Logged = FALSE;

int n_AutoSeq = 0;

struct UART_Data
{
  bool ReadComplete;
  uint8_t index, LastRecive;
  uint8_t ReceiveData[24];
} uart1;
typedef struct
{
  bool Timer_Full;
  bool Timer_Config;
}timerFlag;

timerFlag microsec;
//************
void main()
{
  rccConfig();
  ioInit();
  uartInit(115200);
  char BLE_Name[12];
  while(TRUE)
  {
    switch(n_AutoSeq)
    {
    case 0: //Buzzer On, BLE Power On
      {
        speak_Ring(r_Start, 7);
        GPIO_WriteLow(Power_Port, Power_Pin);
        GPIO_WriteHigh(BLE_PWC_Port, BLE_PWC);
        GPIO_WriteHigh(BLE_Power_Port, BLE_Power);
        n_AutoSeq++;
        break;
      }
    case 1: // Wait connect
      {
        if(delay_us(1995))
        {
          microsec.Timer_Full = FALSE;
          GPIO_WriteReverse(Led_Port, Led_Pin);
        }
        if(uart1.ReadComplete)
        {
          uart1.ReadComplete = FALSE;
          if(strcmp((char*)uart1.ReceiveData, "+CONNECTED") == 0)
          {
            speak_Ring(r_Recive, 2);
            n_AutoSeq++;
          }
        }
        else if(GPIO_ReadInputPin(Key_Port, Key_Pin) == 0x10)
        {
          if(FALSE) // wait 10 sec
          {
            n_AutoSeq = 6;
          }
        }
        else if (FALSE) // after 24 hour
        {
          GPIO_WriteLow(BLE_Power_Port, BLE_Power);
          n_AutoSeq = 5;
        }
        else millis = 0;
        break;
      }
    case 2: // Wait key On
      {
        if(GPIO_ReadInputPin(Key_Port, Key_Pin) == 0x10)
        {
          speak_Ring(r_Recive, 2);
          uartSend("\nReady...");
          n_AutoSeq++;
        }
        else if(uart1.ReadComplete)
        {
          uart1.ReadComplete = FALSE;
          if(strcmp((char*)uart1.ReceiveData, "+FIND_DEVICE") == 0)
          {
            speak_Ring(r_Recive, 2);
            uartSend("*");
          }
          else if(strcmp((char*)uart1.ReceiveData, "+DISCONNECT") == 0)
          {
            speak_Ring(r_Error, 1);
            n_AutoSeq = 1;
          }
          else
          {
            uartSend("\nSwitch key to ON");
          }
        }
        break;
      }
    case 3: // Wait turn On motor
      {
        if(uart1.ReadComplete)
        {
          uart1.ReadComplete = FALSE;
          memset(BLE_Name, 0, strlen(BLE_Name));
          strncpy(BLE_Name, (char*)uart1.ReceiveData, 7);
          if(strcmp((char*)uart1.ReceiveData, "+MOTOR_ON") == 0)
          {
            uartSend("\nMotor is On");
            GPIO_WriteHigh(Power_Port, Power_Pin);
            n_AutoSeq++;
          }
          else if (strcmp(BLE_Name, "AT+NAME") == 0)
          {
//            memset(BLE_Name, 0, strlen(BLE_Name));
//            strncpy(BLE_Name, (char*)uart1.ReceiveData + 7, 12);
//            uartSend("\nChange name: ");
//            uartSend(BLE_Name);
//            while(!delay_ms(1000));
//            millisec.Timer_Full = FALSE;
//            strcat(BLE_Name, "\r\n");
//            GPIO_WriteLow(BLE_Power_Port, BLE_Power);
//            GPIO_WriteLow(BLE_PWC_Port, BLE_PWC);
//            while(!delay_ms(1000));
//            millisec.Timer_Full = FALSE;
//            GPIO_WriteHigh(BLE_Power_Port, BLE_Power);
//            while(!delay_ms(1000));
//            millisec.Timer_Full = FALSE;
//            uartSend(BLE_Name);
//            while(!delay_ms(1000));
//            millisec.Timer_Full = FALSE;
//            uartSend("AT+DISC\r\n");
//            while(!delay_ms(1000));
//            millisec.Timer_Full = FALSE;
//            GPIO_WriteLow(BLE_Power_Port, BLE_Power);
//            GPIO_WriteHigh(BLE_PWC_Port, BLE_PWC);
//            while(!delay_ms(1000));
//            millisec.Timer_Full = FALSE;
//            GPIO_WriteHigh(BLE_Power_Port, BLE_Power);
            n_AutoSeq = 1;
          }
          else if(strcmp((char*)uart1.ReceiveData, "+DISCONNECT") == 0)
          {
            speak_Ring(r_Error, 1);
            n_AutoSeq = 1;
          }
        }
        break;
      }
    case 4: //Running mode
      {
        if(uart1.ReadComplete | GPIO_ReadInputPin(Key_Port, Key_Pin) == RESET)
        {
          uart1.ReadComplete = FALSE;
          if(strcmp((char*)uart1.ReceiveData, "+MOTOR_ON") == 0 | GPIO_ReadInputPin(Key_Port, Key_Pin) == RESET)
          {
            GPIO_WriteLow(Power_Port, Power_Pin);
            uartSend("\nMotor is Off");
            speak_Ring(r_Stop, 7);
            n_AutoSeq = 2;
          }
          else if(strcmp((char*)uart1.ReceiveData, "+DISCONNECT") == 0)
          {
            n_AutoSeq = 7;
          }
        }
        break;
      }
    case 5: //Sleep mode
      {
        if(GPIO_ReadInputPin(Key_Port, Key_Pin) == SET) n_AutoSeq = 0;
        break;
      }
    case 6: //Alarm
      {
        speak_Ring(r_Recive, 2);
        if(GPIO_ReadInputPin(Key_Port, Key_Pin) == RESET) n_AutoSeq = 1;
        break;
      }
    case 7: // Conection loss
      {
        for(int i = 0; i < 10; i++)
        {
          if(uart1.ReadComplete)
          {
            if(strcmp((char*)uart1.ReceiveData, "+CONNECTED") == 0) n_AutoSeq = 4;
          }
          speak_Ring(r_Error, 1);
          // Delay 1s
        }
        if(n_AutoSeq != 4) n_AutoSeq = 0;
        break;
      }
    }
  }
}


//Funtion process
void rccConfig()
{
  CLK_DeInit();
  CLK_SYSCLKConfig(CLK_PRESCALER_HSIDIV1);
  CLK_ClockSwitchConfig(CLK_SWITCHMODE_AUTO, CLK_SOURCE_HSI, DISABLE, CLK_CURRENTCLOCKSTATE_DISABLE);
}
void uartInit(uint32_t baudRate)
{
  UART1_DeInit();
  UART1_Init(baudRate, UART1_WORDLENGTH_8D, UART1_STOPBITS_1, UART1_PARITY_NO, UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TXRX_ENABLE);
  UART1_ITConfig(UART1_IT_RXNE_OR, ENABLE);
  UART1_Cmd(ENABLE);
  enableInterrupts();
}
void uartSend(char* message)
{
  while(*message)
  {
    UART1_SendData8((uint8_t)*message++);
    while(UART1_GetFlagStatus(UART1_FLAG_TXE) == RESET);
  }
}
void ioInit()
{
  GPIO_DeInit(GPIOA);
  GPIO_DeInit(GPIOC);
  GPIO_DeInit(GPIOD);
  
  GPIO_Init(Key_Port, Key_Pin, GPIO_MODE_IN_FL_NO_IT);
  GPIO_Init(Speaker_Port, Speaker_Pin, GPIO_MODE_OUT_PP_HIGH_FAST);
  GPIO_Init(Led_Port, Led_Pin, GPIO_MODE_OUT_PP_LOW_SLOW);
  
  GPIO_Init(Cps_Ready_Port, Cps_Ready_Pin, GPIO_MODE_IN_FL_NO_IT);
  
  GPIO_Init(Epp_WirteProtect_Port, Epp_WirteProtect_Pin, GPIO_MODE_IN_FL_NO_IT);
  GPIO_Init(Power_Port, Power_Pin, GPIO_MODE_OUT_PP_LOW_SLOW);
  
  GPIO_Init(BLE_Power_Port, BLE_Power, GPIO_MODE_OUT_PP_LOW_SLOW);
  GPIO_Init(BLE_PWC_Port, BLE_PWC, GPIO_MODE_OUT_PP_LOW_SLOW);
}
//bool delay_ms(uint16_t delayTime)
//{
//  if(!millisec.Timer_Config)
//  {
//    float timer_Period = delayTime / 2.048;
//    TIM2_DeInit();
//    TIM2_TimeBaseInit(TIM2_PRESCALER_32768, (uint16_t)timer_Period - 1);
//    TIM2_ClearFlag(TIM2_FLAG_UPDATE);
//    TIM2_ITConfig(TIM2_IT_UPDATE, ENABLE);
//    TIM2_Cmd(ENABLE);
//    millisec.Timer_Config = TRUE;
//  }
//  return millisec.Timer_Full;
//}
bool delay_us(uint16_t delayTime)
{
  if(!microsec.Timer_Config)
  {
    float timer_Period = delayTime / 0.008;
    TIM4_DeInit();
    TIM4_TimeBaseInit(TIM4_PRESCALER_128, (uint8_t)timer_Period - 1);
    TIM4_ClearFlag(TIM4_FLAG_UPDATE);
    TIM4_ITConfig(TIM4_IT_UPDATE, ENABLE);
    TIM4_Cmd(ENABLE);
    microsec.Timer_Config = TRUE;
  }
  return microsec.Timer_Full;
}
void speak_Ring(int ring[], int size)
{
  for(int j = 0; j < size; j++)
  {
    for(int i = 0; i < n_Tone; i++)
    {
      GPIO_WriteReverse(Speaker_Port, Speaker_Pin);
      for(int delay = 0; delay < ring[j]; delay++) for(int j = 0; j < 125; j++);
    }
    while(!delay_us(10));
    microsec.Timer_Full = FALSE;
  }
  GPIO_WriteLow(Speaker_Port, Speaker_Pin);
}
void power_IO(bool state)
{
  if(state == FALSE)
  {
    b_Power = FALSE;
    speak_Ring(r_Stop, 7);
    uartSend("Motor is Off\n");
    GPIO_WriteLow(Power_Port, Power_Pin);
  }
  else
  {
    b_Power = TRUE;
    speak_Ring(r_Start, 7);
    uartSend("Motor is On\n");
    GPIO_WriteHigh(Power_Port, Power_Pin);
  }
}
//***************
//Handle Funtion
INTERRUPT_HANDLER(UART1_RX_IRQHandler, 18)
{
  if(UART1_GetITStatus(UART1_IT_RXNE))
  {
    char RxData = UART1_ReceiveData8();
    if(RxData == 0x0A & uart1.LastRecive == 0x0D)
    {
      for(int i = uart1.index; i < sizeof(uart1.ReceiveData); i++) uart1.ReceiveData[i] = 0;
      uart1.index = 0;
      uart1.ReadComplete = TRUE;
    }
    else if(RxData != 0x0D & RxData != 0x0A)
    {
      uart1.ReadComplete = FALSE;
      uart1.ReceiveData[uart1.index] = RxData;
      uart1.index++;
    }
    else uart1.LastRecive = RxData;
  }
}
INTERRUPT_HANDLER(TIM2_UPD_OVF_BRK_IRQHandler, 13)
{
  if(TIM2_GetITStatus(TIM2_IT_UPDATE) == SET)
  {
    millisec.Timer_Full = TRUE;
    millisec.Timer_Config = FALSE;
    TIM2_ClearITPendingBit(TIM2_IT_UPDATE);
    TIM2_Cmd(DISABLE);
  }
}
INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 23)
{
  if(TIM4_GetITStatus(TIM4_IT_UPDATE) == SET)
  {
    microsec.Timer_Full = TRUE;
    microsec.Timer_Config = FALSE;
    TIM4_ClearITPendingBit(TIM4_IT_UPDATE);
    TIM4_Cmd(DISABLE);
  }
}
//******************

//STM8 Def
#ifdef USE_FULL_ASSERT

/**
* @brief  Reports the name of the source file and the source line number
*   where the assert_param error has occurred.
* @param file: pointer to the source file name
* @param line: assert_param error line source number
* @retval None
*/
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
  ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* Infinite loop */
  //  uint8_t* s_file = file;
  //  uint32_t t_line = line;
  while (1)
  {
    
  }
}
#endif